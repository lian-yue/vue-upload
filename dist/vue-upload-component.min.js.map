{"version":3,"file":"vue-upload-component.min.js","sources":["../src/utils/request.js","../src/chunk/ChunkUploadHandler.js","../src/FileUpload.vue"],"sourcesContent":["/**\r\n * Creates a XHR request\r\n *\r\n * @param {Object} options\r\n */\r\nexport const createRequest = (options) => {\r\n  const xhr = new XMLHttpRequest()\r\n  xhr.open(options.method || 'GET', options.url)\r\n  xhr.responseType = 'json'\r\n  if (options.headers) {\r\n    Object.keys(options.headers).forEach(key => {\r\n      xhr.setRequestHeader(key, options.headers[key])\r\n    })\r\n  }\r\n\r\n  return xhr\r\n}\r\n\r\n/**\r\n * Sends a XHR request with certain body\r\n *\r\n * @param {XMLHttpRequest} xhr\r\n * @param {Object} body\r\n */\r\nexport const sendRequest = (xhr, body) => {\r\n  return new Promise((resolve, reject) => {\r\n    xhr.onload = () => {\r\n      if (xhr.status >= 200 && xhr.status < 300) {\r\n        var response\r\n        try {\r\n          response = JSON.parse(xhr.response)\r\n        } catch (err) {\r\n          response = xhr.response\r\n        }\r\n        resolve(response)\r\n      } else {\r\n        reject(xhr.response)\r\n      }\r\n    }\r\n    xhr.onerror = () => reject(xhr.response)\r\n    xhr.send(JSON.stringify(body))\r\n  })\r\n}\r\n\r\n/**\r\n * Sends a XHR request with certain form data\r\n *\r\n * @param {XMLHttpRequest} xhr\r\n * @param {Object} data\r\n */\r\nexport const sendFormRequest = (xhr, data) => {\r\n  const body = new FormData()\r\n  for (var name in data) {\r\n    body.append(name, data[name])\r\n  }\r\n\r\n  return new Promise((resolve, reject) => {\r\n    xhr.onload = () => {\r\n      if (xhr.status >= 200 && xhr.status < 300) {\r\n        var response\r\n        try {\r\n          response = JSON.parse(xhr.response)\r\n        } catch (err) {\r\n          response = xhr.response\r\n        }\r\n        resolve(response)\r\n      } else {\r\n        reject(xhr.response)\r\n      }\r\n    }\r\n    xhr.onerror = () => reject(xhr.response)\r\n    xhr.send(body)\r\n  })\r\n}\r\n\r\n/**\r\n * Creates and sends XHR request\r\n *\r\n * @param {Object} options\r\n *\r\n * @returns Promise\r\n */\r\nexport default function (options) {\r\n  const xhr = createRequest(options)\r\n\r\n  return sendRequest(xhr, options.body)\r\n}\r\n","import {\r\n  default as request,\r\n  createRequest,\r\n  sendFormRequest\r\n} from '../utils/request'\r\n\r\nexport default class ChunkUploadHandler {\r\n  /**\r\n   * Constructor\r\n   *\r\n   * @param {File} file\r\n   * @param {Object} options\r\n   */\r\n  constructor (file, options) {\r\n    this.file = file\r\n    this.options = options\r\n  }\r\n\r\n  /**\r\n   * Gets the max retries from options\r\n   */\r\n  get maxRetries () {\r\n    return parseInt(this.options.maxRetries)\r\n  }\r\n\r\n  /**\r\n   * Gets the max number of active chunks being uploaded at once from options\r\n   */\r\n  get maxActiveChunks () {\r\n    return parseInt(this.options.maxActive)\r\n  }\r\n\r\n  /**\r\n   * Gets the file type\r\n   */\r\n  get fileType () {\r\n    return this.file.type\r\n  }\r\n\r\n  /**\r\n   * Gets the file size\r\n   */\r\n  get fileSize () {\r\n    return this.file.size\r\n  }\r\n\r\n  /**\r\n   * Gets the file name\r\n   */\r\n  get fileName () {\r\n    return this.file.name\r\n  }\r\n\r\n  /**\r\n   * Gets action (url) to upload the file\r\n   */\r\n  get action () {\r\n    return this.options.action || null\r\n  }\r\n\r\n  get startAction() {\r\n    return this.options.startAction || this.action\r\n  }\r\n\r\n  get uploadAction() {\r\n    return this.options.uploadAction || this.action\r\n  }\r\n\r\n  get finishAction() {\r\n    return this.options.finishAction || this.action\r\n  }\r\n\r\n  /**\r\n   * Gets the body to be merged when sending the request in start phase\r\n   */\r\n  get startBody () {\r\n    return this.options.startBody || {}\r\n  }\r\n\r\n  /**\r\n   * Gets the body to be merged when sending the request in upload phase\r\n   */\r\n  get uploadBody () {\r\n    return this.options.uploadBody || {}\r\n  }\r\n\r\n  /**\r\n   * Gets the body to be merged when sending the request in finish phase\r\n   */\r\n  get finishBody () {\r\n    return this.options.finishBody || {}\r\n  }\r\n\r\n  /**\r\n   * Gets the headers of the requests from options\r\n   */\r\n  get headers () {\r\n    return this.options.headers || {}\r\n  }\r\n\r\n  /**\r\n   * Whether it's ready to upload files or not\r\n   */\r\n  get readyToUpload () {\r\n    return !!this.chunks\r\n  }\r\n\r\n  /**\r\n   * Gets the progress of the chunk upload\r\n   * - Gets all the completed chunks\r\n   * - Gets the progress of all the chunks that are being uploaded\r\n   */\r\n  get progress () {\r\n    const completedProgress = (this.chunksUploaded.length / this.chunks.length) * 100\r\n    const uploadingProgress = this.chunksUploading.reduce((progress, chunk) => {\r\n      return progress + ((chunk.progress | 0) / this.chunks.length)\r\n    }, 0)\r\n\r\n    return Math.min(completedProgress + uploadingProgress, 100)\r\n  }\r\n\r\n  /**\r\n   * Gets all the chunks that are pending to be uploaded\r\n   */\r\n  get chunksToUpload () {\r\n    return this.chunks.filter(chunk => {\r\n      return !chunk.active && !chunk.uploaded\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Whether there are chunks to upload or not\r\n   */\r\n  get hasChunksToUpload () {\r\n    return this.chunksToUpload.length > 0\r\n  }\r\n\r\n  /**\r\n   * Gets all the chunks that are uploading\r\n   */\r\n  get chunksUploading () {\r\n    return this.chunks.filter(chunk => {\r\n      return !!chunk.xhr && !!chunk.active\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Gets all the chunks that have finished uploading\r\n   */\r\n  get chunksUploaded () {\r\n    return this.chunks.filter(chunk => {\r\n      return !!chunk.uploaded\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Creates all the chunks in the initial state\r\n   */\r\n  createChunks () {\r\n    this.chunks = []\r\n\r\n    let start = 0\r\n    let end = this.chunkSize\r\n    while (start < this.fileSize) {\r\n      this.chunks.push({\r\n        blob: this.file.file.slice(start, end),\r\n        startOffset: start,\r\n        active: false,\r\n        retries: this.maxRetries\r\n      })\r\n      start = end\r\n      end = start + this.chunkSize\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates the progress of the file with the handler's progress\r\n   */\r\n  updateFileProgress () {\r\n    this.file.progress = this.progress\r\n  }\r\n\r\n  /**\r\n   * Paues the upload process\r\n   * - Stops all active requests\r\n   * - Sets the file not active\r\n   */\r\n  pause () {\r\n    this.file.active = false\r\n    this.stopChunks()\r\n  }\r\n\r\n  /**\r\n   * Stops all the current chunks\r\n   */\r\n  stopChunks () {\r\n    this.chunksUploading.forEach(chunk => {\r\n      chunk.xhr.abort()\r\n      chunk.active = false\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Resumes the file upload\r\n   * - Sets the file active\r\n   * - Starts the following chunks\r\n   */\r\n  resume () {\r\n    this.file.active = true\r\n    this.startChunking()\r\n  }\r\n\r\n  /**\r\n   * Starts the file upload\r\n   *\r\n   * @returns Promise\r\n   * - resolve  The file was uploaded\r\n   * - reject   The file upload failed\r\n   */\r\n  upload () {\r\n    this.promise = new Promise((resolve, reject) => {\r\n      this.resolve = resolve\r\n      this.reject = reject\r\n    })\r\n    this.start()\r\n\r\n    return this.promise\r\n  }\r\n\r\n  /**\r\n   * Start phase\r\n   * Sends a request to the backend to initialise the chunks\r\n   */\r\n  start () {\r\n    request({\r\n      method: 'POST',\r\n      headers: Object.assign({}, this.headers, {\r\n        'Content-Type': 'application/json'\r\n      }),\r\n      url: this.startAction,\r\n      body: Object.assign(this.startBody, {\r\n        phase: 'start',\r\n        mime_type: this.fileType,\r\n        size: this.fileSize,\r\n        name: this.fileName\r\n      })\r\n    }).then(res => {\r\n      if (res.status !== 'success') {\r\n        this.file.response = res\r\n        return this.reject('server')\r\n      }\r\n\r\n      this.sessionId = res.data.session_id\r\n      this.chunkSize = res.data.end_offset\r\n\r\n      this.createChunks()\r\n      this.startChunking()\r\n    }).catch(res => {\r\n      this.file.response = res\r\n      this.reject('server')\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Starts to upload chunks\r\n   */\r\n  startChunking () {\r\n    for (let i = 0; i < this.maxActiveChunks; i++) {\r\n      this.uploadNextChunk()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Uploads the next chunk\r\n   * - Won't do anything if the process is paused\r\n   * - Will start finish phase if there are no more chunks to upload\r\n   */\r\n  uploadNextChunk () {\r\n    if (this.file.active) {\r\n      if (this.hasChunksToUpload) {\r\n        return this.uploadChunk(this.chunksToUpload[0])\r\n      }\r\n\r\n      if (this.chunksUploading.length === 0) {\r\n        return this.finish()\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Uploads a chunk\r\n   * - Sends the chunk to the backend\r\n   * - Sets the chunk as uploaded if everything went well\r\n   * - Decreases the number of retries if anything went wrong\r\n   * - Fails if there are no more retries\r\n   *\r\n   * @param {Object} chunk\r\n   */\r\n  uploadChunk (chunk) {\r\n    chunk.progress = 0\r\n    chunk.active = true\r\n    this.updateFileProgress()\r\n    chunk.xhr = createRequest({\r\n      method: 'POST',\r\n      headers: this.headers,\r\n      url: this.uploadAction\r\n    })\r\n\r\n    chunk.xhr.upload.addEventListener('progress', function (evt) {\r\n      if (evt.lengthComputable) {\r\n        chunk.progress = Math.round(evt.loaded / evt.total * 100)\r\n      }\r\n    }, false)\r\n\r\n    sendFormRequest(chunk.xhr, Object.assign(this.uploadBody, {\r\n      phase: 'upload',\r\n      session_id: this.sessionId,\r\n      start_offset: chunk.startOffset,\r\n      chunk: chunk.blob\r\n    })).then(res => {\r\n      chunk.active = false\r\n      if (res.status === 'success') {\r\n        chunk.uploaded = true\r\n      } else {\r\n        if (chunk.retries-- <= 0) {\r\n          this.stopChunks()\r\n          return this.reject('upload')\r\n        }\r\n      }\r\n\r\n      this.uploadNextChunk()\r\n    }).catch(() => {\r\n      chunk.active = false\r\n      if (chunk.retries-- <= 0) {\r\n        this.stopChunks()\r\n        return this.reject('upload')\r\n      }\r\n\r\n      this.uploadNextChunk()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Finish phase\r\n   * Sends a request to the backend to finish the process\r\n   */\r\n  finish () {\r\n    this.updateFileProgress()\r\n\r\n    request({\r\n      method: 'POST',\r\n      headers: Object.assign({}, this.headers, {\r\n        'Content-Type': 'application/json'\r\n      }),\r\n      url: this.finishAction,\r\n      body: Object.assign(this.finishBody, {\r\n        phase: 'finish',\r\n        session_id: this.sessionId\r\n      })\r\n    }).then(res => {\r\n      this.file.response = res\r\n      if (res.status !== 'success') {\r\n        return this.reject('server')\r\n      }\r\n\r\n      this.resolve(res)\r\n    }).catch(res => {\r\n      this.file.response = res\r\n      this.reject('server')\r\n    })\r\n  }\r\n}\r\n","<template>\r\n  <span :class=\"className\">\r\n    <slot></slot>\r\n    <label :for=\"inputId || name\"></label>\r\n    <input-file></input-file>\r\n  </span>\r\n</template>\r\n<style>\r\n.file-uploads {\r\n  overflow: hidden;\r\n  position: relative;\r\n  text-align: center;\r\n  display: inline-block;\r\n}\r\n.file-uploads.file-uploads-html4 input, .file-uploads.file-uploads-html5 label {\r\n  /* background fix ie  click */\r\n  background: #fff;\r\n  opacity: 0;\r\n  font-size: 20em;\r\n  z-index: 1;\r\n  top: 0;\r\n  left: 0;\r\n  right: 0;\r\n  bottom: 0;\r\n  position: absolute;\r\n  width: 100%;\r\n  height: 100%;\r\n}\r\n.file-uploads.file-uploads-html5 input, .file-uploads.file-uploads-html4 label {\r\n  /* background fix ie  click */\r\n  background: rgba(255, 255, 255, 0);\r\n  overflow: hidden;\r\n  position: fixed;\r\n  width: 1px;\r\n  height: 1px;\r\n  z-index: -1;\r\n  opacity: 0;\r\n}\r\n</style>\r\n<script>\r\nimport ChunkUploadDefaultHandler from './chunk/ChunkUploadHandler'\r\nimport InputFile from './InputFile.vue'\r\n\r\nconst CHUNK_DEFAULT_OPTIONS = {\r\n  headers: {},\r\n  action: '',\r\n  minSize: 1048576,\r\n  maxActive: 3,\r\n  maxRetries: 5,\r\n\r\n  handler: ChunkUploadDefaultHandler\r\n}\r\n\r\nexport default {\r\n  components: {\r\n    InputFile,\r\n  },\r\n  props: {\r\n    inputId: {\r\n      type: String,\r\n    },\r\n\r\n    name: {\r\n      type: String,\r\n      default: 'file',\r\n    },\r\n\r\n    accept: {\r\n      type: String,\r\n    },\r\n\r\n    capture: {\r\n    },\r\n\r\n    disabled: {\r\n    },\r\n\r\n    multiple: {\r\n      type: Boolean,\r\n    },\r\n\r\n    maximum: {\r\n      type: Number,\r\n      default() {\r\n        return this.multiple ? 0 : 1\r\n      }\r\n    },\r\n\r\n    addIndex: {\r\n      type: [Boolean, Number],\r\n    },\r\n\r\n    directory: {\r\n      type: Boolean,\r\n    },\r\n\r\n    postAction: {\r\n      type: String,\r\n    },\r\n\r\n    putAction: {\r\n      type: String,\r\n    },\r\n\r\n    customAction: {\r\n      type: Function,\r\n    },\r\n\r\n    headers: {\r\n      type: Object,\r\n      default: Object,\r\n    },\r\n\r\n    data: {\r\n      type: Object,\r\n      default: Object,\r\n    },\r\n\r\n    timeout: {\r\n      type: Number,\r\n      default: 0,\r\n    },\r\n\r\n\r\n    drop: {\r\n      default: false,\r\n    },\r\n\r\n    dropDirectory: {\r\n      type: Boolean,\r\n      default: true,\r\n    },\r\n\r\n    size: {\r\n      type: Number,\r\n      default: 0,\r\n    },\r\n\r\n    extensions: {\r\n      default: Array,\r\n    },\r\n\r\n\r\n    value: {\r\n      type: Array,\r\n      default: Array,\r\n    },\r\n\r\n    thread: {\r\n      type: Number,\r\n      default: 1,\r\n    },\r\n\r\n    // Chunk upload enabled\r\n    chunkEnabled: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n\r\n    // Chunk upload properties\r\n    chunk: {\r\n      type: Object,\r\n      default: () => {\r\n        return CHUNK_DEFAULT_OPTIONS\r\n      }\r\n    }\r\n  },\r\n\r\n  data() {\r\n    return {\r\n      files: this.value,\r\n      features: {\r\n        html5: true,\r\n        directory: false,\r\n        drag: false,\r\n      },\r\n\r\n      active: false,\r\n      dropActive: false,\r\n\r\n      uploading: 0,\r\n\r\n      destroy: false,\r\n    }\r\n  },\r\n\r\n\r\n  /**\r\n   * mounted\r\n   * @return {[type]} [description]\r\n   */\r\n  mounted() {\r\n    let input = document.createElement('input')\r\n    input.type = 'file'\r\n    input.multiple = true\r\n\r\n    // html5 特征\r\n    if (window.FormData && input.files) {\r\n      // 上传目录特征\r\n      if (typeof input.webkitdirectory === 'boolean' || typeof input.directory === 'boolean') {\r\n        this.features.directory = true\r\n      }\r\n\r\n      // 拖拽特征\r\n      if (this.features.html5 && typeof input.ondrop !== 'undefined') {\r\n        this.features.drop = true\r\n      }\r\n    } else {\r\n      this.features.html5 = false\r\n    }\r\n\r\n    // files 定位缓存\r\n    this.maps = {}\r\n    if (this.files) {\r\n      for (let i = 0; i < this.files.length; i++) {\r\n        let file = this.files[i]\r\n        this.maps[file.id] = file\r\n      }\r\n    }\r\n\r\n    this.$nextTick(function () {\r\n\r\n      // 更新下父级\r\n      if (this.$parent) {\r\n        this.$parent.$forceUpdate()\r\n        // 拖拽渲染\r\n        this.$parent.$nextTick(() => {\r\n          this.watchDrop(this.drop)\r\n        })\r\n      } else {\r\n        // 拖拽渲染\r\n        this.watchDrop(this.drop)\r\n      }\r\n    })\r\n  },\r\n\r\n  /**\r\n   * beforeDestroy\r\n   * @return {[type]} [description]\r\n   */\r\n  beforeDestroy() {\r\n    // 已销毁\r\n    this.destroy = true\r\n\r\n    // 设置成不激活\r\n    this.active = false\r\n\r\n    // 销毁拖拽事件\r\n    this.watchDrop(false)\r\n  },\r\n\r\n  computed: {\r\n    /**\r\n     * uploading 正在上传的线程\r\n     * @return {[type]} [description]\r\n     */\r\n\r\n    /**\r\n     * uploaded 文件列表是否全部已上传\r\n     * @return {[type]} [description]\r\n     */\r\n    uploaded() {\r\n      let file\r\n      for (let i = 0; i < this.files.length; i++) {\r\n        file = this.files[i]\r\n        if (file.fileObject && !file.error && !file.success) {\r\n          return false\r\n        }\r\n      }\r\n      return true\r\n    },\r\n\r\n    chunkOptions () {\r\n      return Object.assign(CHUNK_DEFAULT_OPTIONS, this.chunk)\r\n    },\r\n\r\n    className() {\r\n      return [\r\n        'file-uploads',\r\n        this.features.html5 ? 'file-uploads-html5' : 'file-uploads-html4',\r\n        this.features.directory && this.directory ? 'file-uploads-directory' : undefined,\r\n        this.features.drop && this.drop ? 'file-uploads-drop' : undefined,\r\n        this.disabled ? 'file-uploads-disabled' : undefined,\r\n      ]\r\n    }\r\n  },\r\n\r\n\r\n  watch: {\r\n    active(active) {\r\n      this.watchActive(active)\r\n    },\r\n\r\n    dropActive() {\r\n      if (this.$parent) {\r\n        this.$parent.$forceUpdate()\r\n      }\r\n    },\r\n\r\n    drop(value) {\r\n      this.watchDrop(value)\r\n    },\r\n\r\n    value(files) {\r\n      if (this.files === files) {\r\n        return\r\n      }\r\n      this.files = files\r\n\r\n      let oldMaps = this.maps\r\n\r\n      // 重写 maps 缓存\r\n      this.maps = {}\r\n      for (let i = 0; i < this.files.length; i++) {\r\n        let file = this.files[i]\r\n        this.maps[file.id] = file\r\n      }\r\n\r\n      // add, update\r\n      for (let key in this.maps) {\r\n        let newFile = this.maps[key]\r\n        let oldFile = oldMaps[key]\r\n        if (newFile !== oldFile) {\r\n          this.emitFile(newFile, oldFile)\r\n        }\r\n      }\r\n\r\n      // delete\r\n      for (let key in oldMaps) {\r\n        if (!this.maps[key]) {\r\n          this.emitFile(undefined, oldMaps[key])\r\n        }\r\n      }\r\n    },\r\n  },\r\n\r\n  methods: {\r\n\r\n    // 清空\r\n    clear() {\r\n      if (this.files.length) {\r\n        let files = this.files\r\n        this.files = []\r\n\r\n        // 定位\r\n        this.maps = {}\r\n\r\n        // 事件\r\n        this.emitInput()\r\n        for (let i = 0; i < files.length; i++) {\r\n          this.emitFile(undefined, files[i])\r\n        }\r\n      }\r\n      return true\r\n    },\r\n\r\n    // 选择\r\n    get(id) {\r\n      if (!id) {\r\n        return false\r\n      }\r\n\r\n      if (typeof id === 'object') {\r\n        return this.maps[id.id] || false\r\n      }\r\n\r\n      return this.maps[id] || false\r\n    },\r\n\r\n    // 添加\r\n    add(_files, index = this.addIndex) {\r\n      let files = _files\r\n      let isArray = files instanceof Array\r\n\r\n      // 不是数组整理成数组\r\n      if (!isArray) {\r\n        files = [files]\r\n      }\r\n\r\n      // 遍历规范对象\r\n      let addFiles = []\r\n      for (let i = 0; i < files.length; i++) {\r\n        let file = files[i]\r\n        if (this.features.html5 && file instanceof Blob) {\r\n          file = {\r\n            file,\r\n            size: file.size,\r\n            name: file.webkitRelativePath || file.relativePath || file.name || 'unknown',\r\n            type: file.type,\r\n          }\r\n        }\r\n        let fileObject = false\r\n        if (file.fileObject === false) {\r\n          // false\r\n        } else if (file.fileObject) {\r\n          fileObject = true\r\n        } else if (typeof Element !== 'undefined' && file.el instanceof Element) {\r\n          fileObject = true\r\n        } else if (typeof Blob !== 'undefined' && file.file instanceof Blob) {\r\n          fileObject = true\r\n        }\r\n        if (fileObject) {\r\n          file = {\r\n            fileObject: true,\r\n            size: -1,\r\n            name: 'Filename',\r\n            type: '',\r\n            active: false,\r\n            error: '',\r\n            success: false,\r\n            putAction: this.putAction,\r\n            postAction: this.postAction,\r\n            timeout: this.timeout,\r\n            ...file,\r\n            response: {},\r\n\r\n            progress: '0.00',          // 只读\r\n            speed: 0,                  // 只读\r\n            // xhr: false,                // 只读\r\n            // iframe: false,             // 只读\r\n          }\r\n\r\n          file.data = {\r\n            ...this.data,\r\n            ...file.data ? file.data : {},\r\n          }\r\n\r\n          file.headers = {\r\n            ...this.headers,\r\n            ...file.headers ? file.headers : {},\r\n          }\r\n        }\r\n\r\n        // 必须包含 id\r\n        if (!file.id) {\r\n          file.id = Math.random().toString(36).substr(2)\r\n        }\r\n\r\n        if (this.emitFilter(file, undefined)) {\r\n          continue\r\n        }\r\n\r\n        // 最大数量限制\r\n        if (this.maximum > 1 && (addFiles.length + this.files.length) >= this.maximum) {\r\n          break\r\n        }\r\n\r\n        addFiles.push(file)\r\n\r\n        // 最大数量限制\r\n        if (this.maximum === 1) {\r\n          break\r\n        }\r\n      }\r\n\r\n      // 没有文件\r\n      if (!addFiles.length) {\r\n        return false\r\n      }\r\n\r\n      // 如果是 1 清空\r\n      if (this.maximum === 1) {\r\n        this.clear()\r\n      }\r\n\r\n\r\n      // 添加进去 files\r\n      let newFiles\r\n      if (index === true || index === 0) {\r\n        newFiles = addFiles.concat(this.files)\r\n      } else if (index) {\r\n        newFiles = this.files.concat([])\r\n        newFiles.splice(index, 0, ...addFiles)\r\n      } else {\r\n        newFiles = this.files.concat(addFiles)\r\n      }\r\n\r\n      this.files = newFiles\r\n\r\n      // 定位\r\n      for (let i = 0; i < addFiles.length; i++) {\r\n        let file = addFiles[i]\r\n        this.maps[file.id] = file\r\n      }\r\n\r\n      // 事件\r\n      this.emitInput()\r\n      for (let i = 0; i < addFiles.length; i++) {\r\n        this.emitFile(addFiles[i], undefined)\r\n      }\r\n\r\n      return isArray ? addFiles : addFiles[0]\r\n    },\r\n\r\n\r\n\r\n    // 添加表单文件\r\n    addInputFile(el) {\r\n      let files = []\r\n      if (el.files) {\r\n        for (let i = 0; i < el.files.length; i++) {\r\n          let file = el.files[i]\r\n          files.push({\r\n            size: file.size,\r\n            name: file.webkitRelativePath || file.relativePath || file.name,\r\n            type: file.type,\r\n            file,\r\n          })\r\n        }\r\n      } else {\r\n        var names = el.value.replace(/\\\\/g, '/').split('/')\r\n        delete el.__vuex__\r\n        files.push({\r\n          name: names[names.length - 1],\r\n          el,\r\n        })\r\n      }\r\n      return this.add(files)\r\n    },\r\n\r\n\r\n    // 添加 DataTransfer\r\n    addDataTransfer(dataTransfer) {\r\n      let files = []\r\n      if (dataTransfer.items && dataTransfer.items.length) {\r\n        let items = []\r\n        for (let i = 0; i < dataTransfer.items.length; i++) {\r\n          let item = dataTransfer.items[i]\r\n          if (item.getAsEntry) {\r\n            item = item.getAsEntry() || item.getAsFile()\r\n          } else if (item.webkitGetAsEntry) {\r\n            item = item.webkitGetAsEntry() || item.getAsFile()\r\n          } else {\r\n            item = item.getAsFile()\r\n          }\r\n          if (item) {\r\n            items.push(item)\r\n          }\r\n        }\r\n\r\n        return new Promise((resolve, reject) => {\r\n          let forEach = (i) => {\r\n            let item = items[i]\r\n            // 结束 文件数量大于 最大数量\r\n            if (!item || (this.maximum > 0 && files.length >= this.maximum)) {\r\n              return resolve(this.add(files))\r\n            }\r\n            this.getEntry(item).then(function (results) {\r\n              files.push(...results)\r\n              forEach(i + 1)\r\n            })\r\n          }\r\n          forEach(0)\r\n        })\r\n      }\r\n\r\n      if (dataTransfer.files.length) {\r\n        for (let i = 0; i < dataTransfer.files.length; i++) {\r\n          files.push(dataTransfer.files[i])\r\n          if (this.maximum > 0 && files.length >= this.maximum) {\r\n            break\r\n          }\r\n        }\r\n        return Promise.resolve(this.add(files))\r\n      }\r\n\r\n      return Promise.resolve([])\r\n    },\r\n\r\n\r\n    // 获得 entry\r\n    getEntry(entry, path = '') {\r\n      return new Promise((resolve, reject) => {\r\n        if (entry.isFile) {\r\n          entry.file(function (file) {\r\n            resolve([\r\n              {\r\n                size: file.size,\r\n                name: path + file.name,\r\n                type: file.type,\r\n                file,\r\n              }\r\n            ])\r\n          })\r\n        } else if (entry.isDirectory && this.dropDirectory) {\r\n          let files = []\r\n          let dirReader = entry.createReader()\r\n          let readEntries = () => {\r\n            dirReader.readEntries((entries) => {\r\n              let forEach = (i) => {\r\n                if ((!entries[i] && i === 0) || (this.maximum > 0 && files.length >= this.maximum)) {\r\n                  return resolve(files)\r\n                }\r\n                if (!entries[i]) {\r\n                  return readEntries()\r\n                }\r\n                this.getEntry(entries[i], path + entry.name + '/').then((results) => {\r\n                  files.push(...results)\r\n                  forEach(i + 1)\r\n                })\r\n              }\r\n              forEach(0)\r\n            })\r\n          }\r\n          readEntries()\r\n        } else {\r\n          resolve([])\r\n        }\r\n      })\r\n    },\r\n\r\n\r\n    replace(id1, id2) {\r\n      let file1 = this.get(id1)\r\n      let file2 = this.get(id2)\r\n      if (!file1 || !file2 || file1 === file2) {\r\n        return false\r\n      }\r\n      let files = this.files.concat([])\r\n      let index1 = files.indexOf(file1)\r\n      let index2 = files.indexOf(file2)\r\n      if (index1 === -1 || index2 === -1) {\r\n        return false\r\n      }\r\n      files[index1] = file2\r\n      files[index2] = file1\r\n      this.files = files\r\n      this.emitInput()\r\n      return true\r\n    },\r\n\r\n    // 移除\r\n    remove(id) {\r\n      let file = this.get(id)\r\n      if (file) {\r\n        if (this.emitFilter(undefined, file)) {\r\n          return false\r\n        }\r\n        let files = this.files.concat([])\r\n        let index = files.indexOf(file)\r\n        if (index === -1) {\r\n          console.error('remove', file)\r\n          return false\r\n        }\r\n        files.splice(index, 1)\r\n        this.files = files\r\n\r\n        // 定位\r\n        delete this.maps[file.id]\r\n\r\n        // 事件\r\n        this.emitInput()\r\n        this.emitFile(undefined, file)\r\n      }\r\n      return file\r\n    },\r\n\r\n    // 更新\r\n    update(id, data) {\r\n      let file = this.get(id)\r\n      if (file) {\r\n        let newFile = {\r\n          ...file,\r\n          ...data\r\n        }\r\n        // 停用必须加上错误\r\n        if (file.fileObject && file.active && !newFile.active && !newFile.error && !newFile.success) {\r\n          newFile.error = 'abort'\r\n        }\r\n\r\n        if (this.emitFilter(newFile, file)) {\r\n          return false\r\n        }\r\n\r\n        let files = this.files.concat([])\r\n        let index = files.indexOf(file)\r\n        if (index === -1) {\r\n          console.error('update', file)\r\n          return false\r\n        }\r\n        files.splice(index, 1, newFile)\r\n        this.files = files\r\n\r\n        // 删除  旧定位 写入 新定位 （已便支持修改id)\r\n        delete this.maps[file.id]\r\n        this.maps[newFile.id] = newFile\r\n\r\n        // 事件\r\n        this.emitInput()\r\n        this.emitFile(newFile, file)\r\n        return newFile\r\n      }\r\n      return false\r\n    },\r\n\r\n\r\n\r\n    // 预处理 事件 过滤器\r\n    emitFilter(newFile, oldFile) {\r\n      let isPrevent = false\r\n      this.$emit('input-filter', newFile, oldFile, function () {\r\n        isPrevent = true\r\n        return isPrevent\r\n      })\r\n      return isPrevent\r\n    },\r\n\r\n    // 处理后 事件 分发\r\n    emitFile(newFile, oldFile) {\r\n      this.$emit('input-file', newFile, oldFile)\r\n      if (newFile && newFile.fileObject && newFile.active && (!oldFile || !oldFile.active)) {\r\n        this.uploading++\r\n        // 激活\r\n        this.$nextTick(function () {\r\n          setTimeout(() => {\r\n            this.upload(newFile).then(() => {\r\n              // eslint-disable-next-line\r\n              newFile = this.get(newFile)\r\n              if (newFile && newFile.fileObject) {\r\n                this.update(newFile, {\r\n                  active: false,\r\n                  success: !newFile.error\r\n                })\r\n              }\r\n            }).catch((e) => {\r\n              this.update(newFile, {\r\n                active: false,\r\n                success: false,\r\n                error: e.code || e.error || e.message || e\r\n              })\r\n            })\r\n          }, parseInt(Math.random() * 50 + 50, 10))\r\n        })\r\n      } else if ((!newFile || !newFile.fileObject || !newFile.active) && oldFile && oldFile.fileObject && oldFile.active) {\r\n        // 停止\r\n        this.uploading--\r\n      }\r\n\r\n      // 自动延续激活\r\n      if (this.active && (Boolean(newFile) !== Boolean(oldFile) || newFile.active !== oldFile.active)) {\r\n        this.watchActive(true)\r\n      }\r\n    },\r\n\r\n    emitInput() {\r\n      this.$emit('input', this.files)\r\n    },\r\n\r\n\r\n    // 上传\r\n    upload(id) {\r\n      let file = this.get(id)\r\n\r\n      // 被删除\r\n      if (!file) {\r\n        return Promise.reject('not_exists')\r\n      }\r\n\r\n      // 不是文件对象\r\n      if (!file.fileObject) {\r\n        return Promise.reject('file_object')\r\n      }\r\n\r\n      // 有错误直接响应\r\n      if (file.error) {\r\n        return Promise.reject(file.error)\r\n      }\r\n\r\n      // 已完成直接响应\r\n      if (file.success) {\r\n        return Promise.resolve(file)\r\n      }\r\n\r\n      // 后缀\r\n      let extensions = this.extensions\r\n      if (extensions && (extensions.length || typeof extensions.length === 'undefined')) {\r\n        if (typeof extensions !== 'object' || !(extensions instanceof RegExp)) {\r\n          if (typeof extensions === 'string') {\r\n            extensions = extensions.split(',').map(value => value.trim()).filter(value => value)\r\n          }\r\n          extensions = new RegExp('\\\\.(' + extensions.join('|').replace(/\\./g, '\\\\.') + ')$', 'i')\r\n        }\r\n        if (file.name.search(extensions) === -1) {\r\n          return Promise.reject('extension')\r\n        }\r\n      }\r\n\r\n      // 大小\r\n      if (this.size > 0 && file.size >= 0 && file.size > this.size) {\r\n        return Promise.reject('size')\r\n      }\r\n\r\n      if (this.customAction) {\r\n        return this.customAction(file, this)\r\n      }\r\n\r\n      if (this.features.html5) {\r\n        if (this.shouldUseChunkUpload(file)) {\r\n          return this.uploadChunk(file)\r\n        }\r\n        if (file.putAction) {\r\n          return this.uploadPut(file)\r\n        }\r\n        if (file.postAction) {\r\n          return this.uploadHtml5(file)\r\n        }\r\n      }\r\n      if (file.postAction) {\r\n        return this.uploadHtml4(file)\r\n      }\r\n      return Promise.reject('No action configured')\r\n    },\r\n\r\n    /**\r\n     * Whether this file should be uploaded using chunk upload or not\r\n     *\r\n     * @param Object file\r\n     */\r\n    shouldUseChunkUpload (file) {\r\n      return this.chunkEnabled &&\r\n        !!this.chunkOptions.handler &&\r\n        file.size > this.chunkOptions.minSize\r\n    },\r\n\r\n    /**\r\n     * Upload a file using Chunk method\r\n     *\r\n     * @param File file\r\n     */\r\n    uploadChunk (file) {\r\n      const HandlerClass = this.chunkOptions.handler\r\n      file.chunk = new HandlerClass(file, this.chunkOptions)\r\n\r\n      return file.chunk.upload()\r\n    },\r\n\r\n    uploadPut(file) {\r\n      let querys = []\r\n      let value\r\n      for (let key in file.data) {\r\n        value = file.data[key]\r\n        if (value !== null && value !== undefined) {\r\n          querys.push(encodeURIComponent(key) + '=' + encodeURIComponent(value))\r\n        }\r\n      }\r\n      let queryString = querys.length ? (file.putAction.indexOf('?') === -1 ? '?' : '&') + querys.join('&') : ''\r\n      let xhr = new XMLHttpRequest()\r\n      xhr.open('PUT', file.putAction + queryString)\r\n      return this.uploadXhr(xhr, file, file.file)\r\n    },\r\n\r\n    uploadHtml5(file) {\r\n      let form = new window.FormData()\r\n      let value\r\n      for (let key in file.data) {\r\n        value = file.data[key]\r\n        if (value && typeof value === 'object' && typeof value.toString !== 'function') {\r\n          if (value instanceof File) {\r\n            form.append(key, value, value.name)\r\n          } else {\r\n            form.append(key, JSON.stringify(value))\r\n          }\r\n        } else if (value !== null && value !== undefined) {\r\n          form.append(key, value)\r\n        }\r\n      }\r\n      form.append(this.name, file.file, file.file.filename || file.name)\r\n      let xhr = new XMLHttpRequest()\r\n      xhr.open('POST', file.postAction)\r\n      return this.uploadXhr(xhr, file, form)\r\n    },\r\n\r\n    uploadXhr(xhr, _file, body) {\r\n      let file = _file\r\n      let speedTime = 0\r\n      let speedLoaded = 0\r\n\r\n      // 进度条\r\n      xhr.upload.onprogress = (e) => {\r\n        // 还未开始上传 已删除 未激活\r\n        file = this.get(file)\r\n        if (!e.lengthComputable || !file || !file.fileObject || !file.active) {\r\n          return\r\n        }\r\n\r\n        // 进度 速度 每秒更新一次\r\n        let speedTime2 = Math.round(Date.now() / 1000)\r\n        if (speedTime2 === speedTime) {\r\n          return\r\n        }\r\n        speedTime = speedTime2\r\n\r\n        file = this.update(file, {\r\n          progress: (e.loaded / e.total * 100).toFixed(2),\r\n          speed: e.loaded - speedLoaded,\r\n        })\r\n        speedLoaded = e.loaded\r\n      }\r\n\r\n      // 检查激活状态\r\n      let interval = setInterval(() => {\r\n        file = this.get(file)\r\n        if (file && file.fileObject && !file.success && !file.error && file.active) {\r\n          return\r\n        }\r\n\r\n        if (interval) {\r\n          clearInterval(interval)\r\n          interval = false\r\n        }\r\n\r\n        try {\r\n          xhr.abort()\r\n          xhr.timeout = 1\r\n        } catch (e) {\r\n        }\r\n      }, 100)\r\n\r\n      return new Promise((resolve, reject) => {\r\n        let complete\r\n        let fn = (e) => {\r\n          // 已经处理过了\r\n          if (complete) {\r\n            return\r\n          }\r\n          complete = true\r\n          if (interval) {\r\n            clearInterval(interval)\r\n            interval = false\r\n          }\r\n\r\n          file = this.get(file)\r\n\r\n          // 不存在直接响应\r\n          if (!file) {\r\n            return reject('not_exists')\r\n          }\r\n\r\n          // 不是文件对象\r\n          if (!file.fileObject) {\r\n            return reject('file_object')\r\n          }\r\n\r\n          // 有错误自动响应\r\n          if (file.error) {\r\n            return reject(file.error)\r\n          }\r\n\r\n          // 未激活\r\n          if (!file.active) {\r\n            return reject('abort')\r\n          }\r\n\r\n\r\n          // 已完成 直接相应\r\n          if (file.success) {\r\n            return resolve(file)\r\n          }\r\n\r\n          let data = {}\r\n\r\n          switch (e.type) {\r\n            case 'timeout':\r\n            case 'abort':\r\n              data.error = e.type\r\n              break\r\n            case 'error':\r\n              if (!xhr.status) {\r\n                data.error = 'network'\r\n              } else if (xhr.status >= 500) {\r\n                data.error = 'server'\r\n              } else if (xhr.status >= 400) {\r\n                data.error = 'denied'\r\n              }\r\n              break\r\n            default:\r\n              if (xhr.status >= 500) {\r\n                data.error = 'server'\r\n              } else if (xhr.status >= 400) {\r\n                data.error = 'denied'\r\n              } else {\r\n                data.progress = '100.00'\r\n              }\r\n          }\r\n\r\n          if (xhr.responseText) {\r\n            let contentType = xhr.getResponseHeader('Content-Type')\r\n            if (contentType && contentType.indexOf('/json') !== -1) {\r\n              data.response = JSON.parse(xhr.responseText)\r\n            } else {\r\n              data.response = xhr.responseText\r\n            }\r\n          }\r\n\r\n          // 更新\r\n          file = this.update(file, data)\r\n\r\n          // 相应错误\r\n          if (file.error) {\r\n            return reject(file.error)\r\n          }\r\n\r\n          // 响应\r\n          return resolve(file)\r\n        }\r\n\r\n        // 事件\r\n        xhr.onload = fn\r\n        xhr.onerror = fn\r\n        xhr.onabort = fn\r\n        xhr.ontimeout = fn\r\n\r\n        // 超时\r\n        if (file.timeout) {\r\n          xhr.timeout = file.timeout\r\n        }\r\n\r\n        // headers\r\n        for (let key in file.headers) {\r\n          xhr.setRequestHeader(key, file.headers[key])\r\n        }\r\n\r\n        // 更新 xhr\r\n        file = this.update(file, { xhr })\r\n\r\n        // 开始上传\r\n        xhr.send(body)\r\n      })\r\n    },\r\n\r\n\r\n\r\n\r\n    uploadHtml4(_file) {\r\n      let file = _file\r\n      let onKeydown = function (e) {\r\n        if (e.keyCode === 27) {\r\n          e.preventDefault()\r\n        }\r\n      }\r\n\r\n      let iframe = document.createElement('iframe')\r\n      iframe.id = 'upload-iframe-' + file.id\r\n      iframe.name = 'upload-iframe-' + file.id\r\n      iframe.src = 'about:blank'\r\n      iframe.setAttribute('style', 'width:1px;height:1px;top:-999em;position:absolute; margin-top:-999em;')\r\n\r\n\r\n      let form = document.createElement('form')\r\n\r\n      form.action = file.postAction\r\n\r\n      form.name = 'upload-form-' + file.id\r\n\r\n\r\n      form.setAttribute('method', 'POST')\r\n      form.setAttribute('target', 'upload-iframe-' + file.id)\r\n      form.setAttribute('enctype', 'multipart/form-data')\r\n\r\n      let value\r\n      let input\r\n      for (let key in file.data) {\r\n        value = file.data[key]\r\n        if (value && typeof value === 'object' && typeof value.toString !== 'function') {\r\n          value = JSON.stringify(value)\r\n        }\r\n        if (value !== null && value !== undefined) {\r\n          input = document.createElement('input')\r\n          input.type = 'hidden'\r\n          input.name = key\r\n          input.value = value\r\n          form.appendChild(input)\r\n        }\r\n      }\r\n      form.appendChild(file.el)\r\n\r\n      document.body.appendChild(iframe).appendChild(form)\r\n\r\n\r\n\r\n\r\n      let getResponseData = function () {\r\n        let doc\r\n        try {\r\n          if (iframe.contentWindow) {\r\n            doc = iframe.contentWindow.document\r\n          }\r\n        } catch (err) {\r\n        }\r\n        if (!doc) {\r\n          try {\r\n            doc = iframe.contentDocument ? iframe.contentDocument : iframe.document\r\n          } catch (err) {\r\n            doc = iframe.document\r\n          }\r\n        }\r\n        if (doc && doc.body) {\r\n          return doc.body.innerHTML\r\n        }\r\n        return null\r\n      }\r\n\r\n\r\n      return new Promise((resolve, reject) => {\r\n        setTimeout(() => {\r\n          file = this.update(file, { iframe })\r\n\r\n          // 不存在\r\n          if (!file) {\r\n            return reject('not_exists')\r\n          }\r\n\r\n          // 定时检查\r\n          let interval = setInterval(() => {\r\n            file = this.get(file)\r\n            if (file && file.fileObject && !file.success && !file.error && file.active) {\r\n              return\r\n            }\r\n\r\n            if (interval) {\r\n              clearInterval(interval)\r\n              interval = false\r\n            }\r\n\r\n            iframe.onabort({ type: file ? 'abort' : 'not_exists' })\r\n          }, 100)\r\n\r\n\r\n          let complete\r\n          let fn = (e) => {\r\n            // 已经处理过了\r\n            if (complete) {\r\n              return\r\n            }\r\n            complete = true\r\n\r\n\r\n            if (interval) {\r\n              clearInterval(interval)\r\n              interval = false\r\n            }\r\n\r\n            // 关闭 esc 事件\r\n            document.body.removeEventListener('keydown', onKeydown)\r\n\r\n            file = this.get(file)\r\n\r\n            // 不存在直接响应\r\n            if (!file) {\r\n              return reject('not_exists')\r\n            }\r\n\r\n            // 不是文件对象\r\n            if (!file.fileObject) {\r\n              return reject('file_object')\r\n            }\r\n\r\n            // 有错误自动响应\r\n            if (file.error) {\r\n              return reject(file.error)\r\n            }\r\n\r\n            // 未激活\r\n            if (!file.active) {\r\n              return reject('abort')\r\n            }\r\n\r\n            // 已完成 直接相应\r\n            if (file.success) {\r\n              return resolve(file)\r\n            }\r\n\r\n            let response = getResponseData()\r\n            let data = {}\r\n            switch (e.type) {\r\n              case 'abort':\r\n                data.error = 'abort'\r\n                break\r\n              case 'error':\r\n                if (file.error) {\r\n                  data.error = file.error\r\n                } else if (response === null) {\r\n                  data.error = 'network'\r\n                } else {\r\n                  data.error = 'denied'\r\n                }\r\n                break\r\n              default:\r\n                if (file.error) {\r\n                  data.error = file.error\r\n                } else if (data === null) {\r\n                  data.error = 'network'\r\n                } else {\r\n                  data.progress = '100.00'\r\n                }\r\n            }\r\n\r\n            if (response !== null) {\r\n              if (response && response.substr(0, 1) === '{' && response.substr(response.length - 1, 1) === '}') {\r\n                try {\r\n                  response = JSON.parse(response)\r\n                } catch (err) {\r\n                }\r\n              }\r\n              data.response = response\r\n            }\r\n\r\n            // 更新\r\n            file = this.update(file, data)\r\n\r\n            if (file.error) {\r\n              return reject(file.error)\r\n            }\r\n\r\n            // 响应\r\n            return resolve(file)\r\n          }\r\n\r\n\r\n          // 添加事件\r\n          iframe.onload = fn\r\n          iframe.onerror = fn\r\n          iframe.onabort = fn\r\n\r\n\r\n          // 禁止 esc 键\r\n          document.body.addEventListener('keydown', onKeydown)\r\n\r\n          // 提交\r\n          form.submit()\r\n        }, 50)\r\n      }).then(function (res) {\r\n        iframe.parentNode && iframe.parentNode.removeChild(iframe)\r\n        return res\r\n      }).catch(function (res) {\r\n        iframe.parentNode && iframe.parentNode.removeChild(iframe)\r\n        return res\r\n      })\r\n    },\r\n\r\n\r\n\r\n    watchActive(active) {\r\n      let file\r\n      let index = 0\r\n      while ((file = this.files[index])) {\r\n        index++\r\n        if (!file.fileObject) {\r\n          // 不是文件对象\r\n        } else if (active && !this.destroy) {\r\n          if (this.uploading >= this.thread || (this.uploading && !this.features.html5)) {\r\n            break\r\n          }\r\n          if (!file.active && !file.error && !file.success) {\r\n            this.update(file, { active: true })\r\n          }\r\n        } else {\r\n          if (file.active) {\r\n            this.update(file, { active: false })\r\n          }\r\n        }\r\n      }\r\n      if (this.uploading === 0) {\r\n        this.active = false\r\n      }\r\n    },\r\n\r\n\r\n    watchDrop(_el) {\r\n      let el = _el\r\n      if (!this.features.drop) {\r\n        return\r\n      }\r\n\r\n      // 移除挂载\r\n      if (this.dropElement) {\r\n        try {\r\n          document.removeEventListener('dragenter', this.onDragenter, false)\r\n          document.removeEventListener('dragleave', this.onDragleave, false)\r\n          document.removeEventListener('drop', this.onDocumentDrop, false)\r\n          this.dropElement.removeEventListener('dragover', this.onDragover, false)\r\n          this.dropElement.removeEventListener('drop', this.onDrop, false)\r\n        } catch (e) {\r\n        }\r\n      }\r\n\r\n      if (!el) {\r\n        el = false\r\n      } else if (typeof el === 'string') {\r\n        el = document.querySelector(el) || this.$root.$el.querySelector(el)\r\n      } else if (el === true) {\r\n        el = this.$parent.$el\r\n      }\r\n\r\n      this.dropElement = el\r\n\r\n      if (this.dropElement) {\r\n        document.addEventListener('dragenter', this.onDragenter, false)\r\n        document.addEventListener('dragleave', this.onDragleave, false)\r\n        document.addEventListener('drop', this.onDocumentDrop, false)\r\n        this.dropElement.addEventListener('dragover', this.onDragover, false)\r\n        this.dropElement.addEventListener('drop', this.onDrop, false)\r\n      }\r\n    },\r\n\r\n\r\n    onDragenter(e) {\r\n      e.preventDefault()\r\n      if (this.dropActive) {\r\n        return\r\n      }\r\n      if (!e.dataTransfer) {\r\n        return\r\n      }\r\n      let dt = e.dataTransfer\r\n      if (dt.files && dt.files.length) {\r\n        this.dropActive = true\r\n      } else if (!dt.types) {\r\n        this.dropActive = true\r\n      } else if (dt.types.indexOf && dt.types.indexOf('Files') !== -1) {\r\n        this.dropActive = true\r\n      } else if (dt.types.contains && dt.types.contains('Files')) {\r\n        this.dropActive = true\r\n      }\r\n    },\r\n\r\n    onDragleave(e) {\r\n      e.preventDefault()\r\n      if (!this.dropActive) {\r\n        return\r\n      }\r\n      if (e.target.nodeName === 'HTML' || e.target === e.explicitOriginalTarget || (!e.fromElement && (e.clientX <= 0 || e.clientY <= 0 || e.clientX >= window.innerWidth || e.clientY >= window.innerHeight))) {\r\n        this.dropActive = false\r\n      }\r\n    },\r\n\r\n    onDragover(e) {\r\n      e.preventDefault()\r\n    },\r\n\r\n    onDocumentDrop() {\r\n      this.dropActive = false\r\n    },\r\n\r\n    onDrop(e) {\r\n      e.preventDefault()\r\n      this.addDataTransfer(e.dataTransfer)\r\n    },\r\n  }\r\n}\r\n</script>\r\n"],"names":["createRequest","options","xhr","XMLHttpRequest","open","method","url","responseType","headers","keys","forEach","setRequestHeader","key","body","Promise","resolve","reject","onload","status","response","JSON","parse","err","onerror","send","stringify","ChunkUploadHandler","file","chunks","start","end","this","chunkSize","fileSize","push","slice","maxRetries","progress","active","stopChunks","chunksUploading","abort","startChunking","promise","Object","assign","startAction","startBody","fileType","fileName","then","res","_this2","sessionId","data","session_id","end_offset","createChunks","catch","i","maxActiveChunks","uploadNextChunk","hasChunksToUpload","uploadChunk","chunksToUpload","length","finish","chunk","updateFileProgress","uploadAction","upload","addEventListener","evt","lengthComputable","Math","round","loaded","total","FormData","name","append","uploadBody","startOffset","blob","uploaded","retries","_this3","finishAction","finishBody","_this4","parseInt","maxActive","type","size","action","completedProgress","chunksUploaded","uploadingProgress","reduce","_this5","min","filter"],"mappings":"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"}